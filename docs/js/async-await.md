---
title: 'async await'
---

<h1>Async await</h1>
async/await는 ES8에서 채택되었으며 제너레이터보다 간단하고 가독성 좋게 비동기 처리를 동기처럼 동작하도록 구현할 수 있다. <br>
프로미스를 기반으로 동작하며 프로미스의 then/catch/finally 후속 처리 메서드에 콜백 함수를 전달해서 비동기 처리 결과를 후속 처리할 필요 없이 마치 동기 처리처럼 프로미스가 처리 결과를 반환하도록 구현할 수 있다. <br><br>

## 제너레이터 (Generator)

Es6에서 도입된 제너레이터는 코드 블록의 실행을 일시 중지시켰다가 필요한 시점에 재개할 수 있는 특수한 함수다. <br>
제너레이터는 이터레이터를 발생시키는 함수로 사용되면 function\* 키워드로 선언한다. <br>
제너레이터 함수는 화살표 함수로 정의하 수없으며 new 연산자와 함께 생성자 함수로 호출할 수 없다. <br>
**\*이터레이터(iterator)?** {value, done} 객체를 리턴하는 next()를 가진 값 <br>

```js
// 제너레이터 함수 선언문
function* generatorFunc() {
	yield 1;
}
// 제너레이터 메서드
const obj = {
	*genObjMethod() {
		yield 1;
	},
};
// 제너레이터 클래스 메서드
class GenClass {
	*genClsMethod() {
		yield 1;
	}
}
```

<br>

### \*제너레이터 vs 일반함수

1. **제너레이터 함수는 함수 호출자에게 함수 실행의 제어권을 양도할 수 있다.** <br>
   - 일반 함수를 호출하면 제어권이 함수에게 넘어가고 함수 코드를 일괄 실행한다. (호출 이후 함수 실행을 제어할 수 없다.)
   - 제너레이터 함수는 함수 실행을 함수 호출자가 제어할 수 있다. (함수 제어권을 호출자에게 양도 할 수 있다.)
2. **제너레이터 함수는 함수 호출자와 함수의 상태를 주고 받을 수 있다.** <br>
   - 일반함수는 함수가 실행되고 있는 동안에는 함수 외부에서 함수 내부로 값을 전달하여 함수의 상태를 변경할 수 없다.
   - 제너레이터 함수는 함수 호출자에게 상태를 전달할 수 있고 함수 호출자로부터 양방향으로 상태를 전달받을 수도 있다.
3. **제너레이터 함수를 호출하면 제너레이터 객체를 반환한다.**
   - 일반 함수를 호출하면 함수 코드를 일관 실행하고 값을 반환한다.
   - 제너레이터 함수를 호출하면 함수 코드를 실행하는 것이 아니라 이터러블이면서 동시에 이터레이터인 제너레이터 객체를 반환한다.

**\*이터러블(iterable)?** iterator를 리턴하는 \[Symbol.iterator]() 를 가진 값 <br><br>

### 제너레이터 객체

제너레이터 함수를 호출하면 일반 함수처럼 함수 코드 블록을 실행하는 것이 아니라 제너레이터 객체를 생성해 반환한다. 제너레이터 함수가 반환한 제너레이터 객체는 이터러블이면서 동시에 이터레이터다.

### async/await

제너레이터를 사용해서 비동기 처리를 동기 처리처럼 동작하도록 구현했지만 코드가 장황해지고 가독성이 나쁘다. 이는 async/await를 사용하면 해결할 수 있다.
<Comment />
